#### **Overview**  
The `model` class is defined in `model_class.R`. The class of objects is created using `setRefClass()`.  For more information about reference classes, [see here](http://adv-r.had.co.nz/R5.html).

#### **Fields**
`model` has the following fields:
* `vars`: This is a character vector of the names of the variables in the model.
* `coefs`: This is a named list whose elements are `data.table` objects containing the coefficients of each variable, as well as the upper and lower confidence intervals. The names correspond to the names of the variables.
* `types`: This is a named list whose elements are characters, either `categorical`, `numeric`, or `interaction`.  The names correspond to the names of variables.
* `ints`: This is a named list whose elements are character vectors. The names correspond to variables of type `interaction`. The character vectors will have 2 elements, the first is the categorical piece of the interaction, and the second is the numeric piece of the interaction.

#### **Methods**
`model` has the following methods:  
* `add(var, coef, type, int=NULL)`: This method adds `var` to the `vars` vector, `coef` to the `coefs` list, `type` to the `types` list, and, if specified, `int` to the `ints` list.
* `predict(dt)`: This method accepts a `data.table` as an argument and scores the data on the model. The method loops through `vars`, and for each variable, gets the coefficient table, the variable type, and the interaction pieces, if any. It will perform a different method of calculation depending on if the variable is a categorical, numeric, or interaction variable. It calculates the factor for each variable for each record, creating an n x k `data.table`, where n is the number of records and k is the number of variables. A total prediction column is also calculated by taking the product of each factor. This `data.table` is then returned by the method.
* `add_design_to_model(design, tbl, fct_col, lower_col, upper_col)`: This method accepts a `table_design` object, a `data.table` object, and column names corresponding to the factor column as well as lower and upper confidence intervals. The `design` argument provided should correspond to the `tbl` argument. These are extracted from a `factor_tables` object, from its `data` and `designs` fields. The `design` argument provides us with the following information from its fields: the grouping levels (`by_vars`), the table type (`type`), categorical variable (`enum_var`), and the numeric piece if any (`num_var`). The `add()` method is used to add the data to the model, but considerations are taken beforehand depending on the type of the table:
  * For tables of type `categorical`, we capture the `enum_var` column of the table and the factor columns and add this to the model. The same logic is applied for `interaction` variables (categorical x numeric), since it is assumed that the variable factor is summarized at some categorical level (this may change in the future). The logic is also applied to `numeric` variables that have been aggregated at some categorical level (`by_vars` is populated).
  * For tables of type `numeric` where `by_vars` is not populated, the table will be a single-row table.  Since there is no `enum_var` here, we create a blank column labelled by `num_var`, so we know the data corresponds to that variable, and capture the numeric coefficients in the (one-row) table.
  * For tables of type `multi-numeric`, we apply the same logic as `numeric` tables, iterating through each row of the table.  A table of n rows would thus create n `numeric` variables, each added to the model.
  * For tables of type `multi-interaction`, we apply the following logic. First, get the numeric pieces of the interactions. The names of these are stored in the `num_var` column of the table. Then, for each numeric piece, we filter the table on records pertaining to that numeric piece (where the `num_var` column equals the name of the numeric variable), and create an `interaction` variable in the model off of the resulting data.
* `check_uniqueness()`: This method is a quality check for the model. For each level of each variable, there should be only 1 coefficient. The method iterates through each table in `coefs`, and compares the number of rows in the table to the number of unique levels present. If they are different, then the method will state that the coefficients are not 1 to 1 and will return FALSE.  Otherwise, it will return TRUE.
