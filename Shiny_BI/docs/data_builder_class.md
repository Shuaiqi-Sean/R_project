#### **Overview**  
The `data_builder` class is defined in `data_builder_class.R`. The class of objects is created using `setRefClass()`.  For more information about reference classes, [see here](http://adv-r.had.co.nz/R5.html).

#### **Fields**
`data_builder` has the following fields:
* `var_src`: a named list where the names correspond to variables.  Opening a `source.R` file shows what each element of this list looks like.  Each element contains `dependencies` (a vector of variables it is dependent on) and a `builder`, a function which appends that variable to a given dataset.
* `built_vars`: A vector containing the names of variables which have been built (their `builder` functions have been called).

#### **Methods**
`data_builder` has the following methods:
* `load_var_lib(path, build_vars)`: `load_var_lib()` looks for folders of the names `build_vars` within `path`.  For each folder, it will run the `source.R` file found within that folder.  The variable `source.R` files should all have the same format, resembling the `source_template.R` file within `data/vars`.
* `build_vars(vars, args, dependencies)`: `build_vars()` receives `vars`, a vector containing variable names which should be built.  It compares these `vars` to the loaded variable definitions within `var_src`, and determines if there are any variables that these variables are dependent on.  It accomplishes this using the `get_parent_tree()` method.  Then, it determines which order these variables should be built.  For instance if `BCG_ME` is a grouping of `SIC_CD`, then `SIC_CD` should be built first.  This order is determined by the `get_build_order` method.  If `dependencies` is `FALSE`, then we instead only build `vars`.  For each variable, we will then find the corresponding `builder` and run it.
* `get_build_order(var_lib, build_order=c())`: This function is a recursive function (a function which calls itself) which, when given a variable library (resembling `var_src`), will determine which variables should be built first given which variables are dependent on others.  Each element of `var_lib` is a named element (the name corresponds to the variable) and each contains a `dependencies` vector, which names the variables it is dependent on.  `get_build_order()` will search through `var_lib` for variables which are dependent on no other variables.  It will add these variables to `build_order`, showing that they should be built first.  It will then remove these variables from `var_lib`.  It will also remove those variables from each elements `dependencies` vector.  If `get_build_order()` finds that after doing so, there are still elements within `var_lib`, it will repeat the process, continuing until `var_lib` is emptied.  After these repetitions, it will return `build_order`, a vector containing which variables to build, in order.
* `get_parent_tree(vars, var_lib, tree=c())`: `get_parent_tree()` is a recursive function which searches the dependencies of given variables.  It will also search the dependencies of dependencies, and so on.  It will return a vector of all dependencies found.
* `get_child_tree(vars, var_lib, tree=c())`: `get_child_tree()` is also a recursive function, similar to `get_parent_tree()`.  This function finds variables which are dependent on those named in `vars`.
* `recommend(path, dt)`: This function compares the `built_vars` to the entire variable library.  It will look for variables which are dependent on `built_vars`, which are also in the dataset, and which have not already been built.
